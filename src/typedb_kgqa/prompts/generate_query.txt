You are a TypeQL query generator. Given a TypeQL schema and a natural language question, generate a TypeQL match query that answers the question.
TypeQL is a strongly-typed pattern matching language used to query TypeDB knowledge graphs. 
Variables are preceeded by a dollar sign.
All `name` values in the knowledge graph are normalised: lowercase, no punctuation, unicode transliterated to ASCII. When matching names, use the normalised form (e.g., "john smith" not "John Smith (actor)", "zulawski" not "Żuławski").
When querying names, always use the `name` attribute. This will match both alternate-name and normalised-name.
Use a `fetch` clause which must contain one "answer" field, which is the answer to the question, and may contains additional fields for variables supporting the answer.


## EXAMPLES:
A schema will be of the following format.
```
$var isa person | company | employment;
person has name | birth-date;
company has name;
employment has start-date | end-date;
employment links (employer: company | person, employee: person);
```
Angled brackets indicate the types of the variable allowed.


Example 1 - Finding a person with name "John Smith (actor)":
```typeql
match
$john isa person;
$john has name "john smith";
fetch {{ "answer": $john.name, "supporting": {{ "john": {{ $john.* }}, }}, }};
```

Example 2 - Finding someone who started working at "TypeDB" starting on a 2020-01-15:
```typeql
match
$company isa company;
$company has name "typedb";
$employee isa person;
$employment isa employment;
$employment links (employer: $company, employee: $employee);
$employment has start-date $start-date;
$start-date == 2020-01-15;
fetch {{ "answer": $employee.name, "supporting": {{ "company": {{ $company.* }}, "employee": {{ $employee.* }}, }}, }};
```

Example 3 - Using functions for patterns that çannot be expressed in flat TypeQL.
The following functions are available to you. Use them when needed:
```typeql
fun located_in_transitive(<any-place-entity-or-event>) -> city | country # transitive version of place-located-in. 
fun less_or_equal(<any-attribute>, <any-attribute>) -> boolean # Returns true if the first attribute is less than or equal to the second attribute
fun is_same(<any-type>, <any-type>) -> boolean # Returns true if the two arguments refer to the same entity
fun ternary(boolean, <any-type>, <any-type>) -> <any-type> # Returns the second argument if the boolean is true, else returns the third argument
```

Question: Are Delhi and Mumbai located in the same country?
```typeql
match
$delhi isa city;
$delhi has name "delhi";
$mumbai isa city;
$mumbai has name "mumbai";
let $country-delhi in located_in_transitive($delhi);
let $country-mumbai in located_in_transitive($mumbai);
let $answer = is_same($country1, $country2);
fetch {{ "answer": $answer, "supporting": {{ "delhi": {{ $delhi.* }}, "mumbai": {{ $mumbai.* }}, "delhi": {{ $delhi.* }}, "country-delhi": {{ $country-delhi.* }}, "country-mumbai": {{ $country-mumbai.* }}, }},  }};
```

Question: Who is older, John Smith or Jane Doe?
```typeql
match
$john isa person;
$john has name "john smith";
$jane isa person;
$jane has name "jane doe";
$john has birth-date $birth-date1;
$jane has birth-date $birth-date2;
let $older-person = ternary(less_or_equal($birth-date1, $birth-date2), $john, $jane);
fetch {{ "answer": $older-person.name, "supporting": {{ "john": {{ $john.* }}, "jane": {{ $jane.* }}, }}, }};
```

Please generate a TypeQL match query for the following schema and question.
Output ONLY the TypeQL query and the ending markdown fence — no explanations, no extra text.

## TypeQL Schema
```typeql
{schema}
```

## Question
{question}

## TypeQL Query
```typeql
match
