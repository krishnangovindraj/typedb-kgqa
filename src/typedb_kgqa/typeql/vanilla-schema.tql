define

#################
# VANILLA SCHEMA
#################
# A flat, concrete schema — no abstract types or deep inheritance.
# Uses a `node-label` attribute on entities and relations to capture
# what would otherwise be encoded via subtypes.

###############
# META / SYSTEM
###############

attribute text-content, value string;
attribute meta-page-title, value string;

entity meta-document, owns meta-page-title, owns text-content;

relation meta-knowledge-source, relates knowledge @card(1), relates source;
meta-document plays meta-knowledge-source:source;
attribute embedding, value string;

###############
# ATTRIBUTES
###############

attribute node-label, value string;        # Replaces subtyping — e.g. "film", "song", "school"
entity entity-node,
    owns meta-page-title @card(0..1),
    owns node-label,
	owns embedding,
    plays meta-knowledge-source:knowledge,
    plays relation-node:related;

# ---- Associations ----
# parentage, marriage, nationality, employment, education,
# film-direction, song-performance, composition, band-membership,
# award-receipt, publishing, etc.
# Use `node-label` to distinguish (e.g. node-label "parentage", node-label "marriage").

relation relation-node,
    owns meta-page-title @card(0..1),
    owns node-label,
	owns embedding,
    relates related @card(0..),
    plays meta-knowledge-source:knowledge;


attribute property @abstract;
attribute string-property sub property, value string;
attribute date-property sub property, value date;
attribute numeric-property sub property, value double;
attribute boolean-property sub property, value boolean;

entity property-node,
    owns node-label,
	owns embedding,
    plays relation-node:related,
    plays meta-knowledge-source:knowledge,
    owns string-property,
    owns date-property,
    owns numeric-property,
    owns boolean-property;

fun embeddings_by_similarity($query-embedding: string) -> { embedding }:
match
    $e isa embedding;
    let $similarity = similarity($query-embedding, $e);
    sort $similarity desc;
    return { $e };

# We don't have a type I can write in the return so I just directly return the documents instead of the nodes.
fun graph_neigbhour_documents_by_similarity($query-embedding: embedding, $embedding-of-node: embedding, $threshold: double) -> { meta-document }:
match
    $node has $embedding-of-node;
    { $_ links ($node, $neighbour); } or { $neighbour links ($node); };
    $neighbour has embedding $neighbour-embedding;
    $_ isa meta-knowledge-source, links (knowledge: $neighbour, source: $document);
    let $similarity = similarity($query-embedding, $neighbour-embedding);
    $similarity >= $threshold;
    reduce $max-similarity = max($similarity) groupby $document;
    distinct;
    sort $max-similarity desc;
return { $document };
